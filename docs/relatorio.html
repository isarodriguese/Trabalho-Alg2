<!DOCTYPE html>
<html lang="pt-br">
<head>
	<meta charset="UTF-8">
	<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@600;800&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="assets/styles.css">
	<title>Relatório</title>
	<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>✿</text></svg>">
</head>

<body>
	<header>
		<h1>Relatório</h1>
	</header>

        <main>
			<section class="card">
				<h2>Como fizemos nosso trabalho:</h2>
				<p class="topicos">Para implementar o Heap, optamos por utilizar um vetor de structs, compostas pelo nome e pela prioridade de cada paciente. Na disciplina de Programação I, aprendemos que, para um vetor muito grande, é uma boa prática evitar a alocação estática. Por isso, optamos por usar a dinâmica em todo o nosso trabalho. Para isso, utilizamos os comandos malloc e realloc.
				</p>
				<p class="topicos">Um outro motivo para essa escolha seria proporcionar à enfermeira uma maior liberdade no uso de seu sistema, uma vez que não é necessário definir um tamanho limite em específico para o vetor.
				</p> 
				<p class="topicos">Além disso, decidimos implementar um MaxHeap, visto que estudamos em Algoritmos II que ele é a estrutura padrão para um Heap. À medida que os pacientes são inseridos, a estrutura da fila de espera se estabelece automaticamente como um Heap. Entretanto, a enfermeira sempre tem a opção de ordenar de modo crescente os pacientes pela prioridade deles, utilizando a função HeapSort.
				</p>
				<h3>Sobre as funções:</h3>
				<p>
				InicHeap: faz o ponteiro para o vetor apontar para NULL e define seu tamanho como zero. 
				</p><p class="topicos">
				InsereHeap: usa o realloc para ajustar a quantidade de memória utilizada pelo vetor e, em seguida, insere o paciente no vetor. Ao final, verifica se o vetor é um Heap e, caso não seja, aciona a função Heapfy.
				</p><p class="topicos">
				ChecaHeap: percorre o vetor, verificando se é um Heap. Retorna 1 se ele for e 0 se não for.
				</p><p class="topicos">
				Heapfy: converte um vetor em MaxHeap.
				</p><p class="topicos">
				RemoveHeap: optamos por implementar uma função que permite remover qualquer paciente da fila de espera. Para isso, ela percorre o vetor, comparando os dados de cada struct, até encontrar o paciente procurado pela enfermeira. Para comparar o nome, usamos uma função de comparação (<em>strcmp()</em>) da biblioteca string.h. Caso o paciente não esteja na fila, ela retorna 0 (erro). Se ele estiver, ela utiliza a função realloc, já ajustando o novo tamanho do vetor. Ao final, se o vetor resultante não for um Heap, ela aciona o Heapfy.
				</p><p class="topicos">
				ImprimeHeap: verifica se a fila possui pacientes, se sim, imprime cada um deles seguindo o padrão (nome prioridade). Senão, imprime uma mensagem informando que a fila está vazia.
				</p><p class="topicos">
				AlteraHeap: de forma semelhante à função RemoveHeap, percorre o vetor, até encontrar o paciente procurado pela enfermeira. Se ele estiver na fila, altera a prioridade dele, para o novo valor, também informado pela enfermeira. Se não, ela imprime uma mensagem informando a ausência do paciente. Ao final, se o vetor resultante não for um Heap, ela aciona o Heapfy.
				</p><p class="topicos">
				SacodeHeap: utilizada exclusivamente no HeapSort, como foi estudado em aula. Percorre um dos nós da Heap, corrigindo a propriedade da estrutura de dados, caso seja necessário.
				</p><p class="topicos">
				HeapSort: ordena um Heap, inserindo o primeiro elemento no final da fila e executando a função SacodeHeap.
				</p><p class="topicos">
				ImprimeMenu: imprime as opções de escolha disponíveis para a enfermeira, no Pronto Socorro.
				</p><p class="topicos">
				ParticionaVetor: utilizada exclusivamente no QuickSort. Seleciona um pivô que, nesse caso, é a mediana entre o primeiro, o último e o elemento do meio, de modo a tentar evitar o pior caso do algoritmo (que possui custo quadrático quando as partes geradas são muito desiguais entre si, ou seja, pivô próximo aos cantos do vetor). Retorna a posição correta do pivô.
				</p><p class="topicos">
				QuickSort: aciona as funções ParticionaVetor e o próprio QuickSort, de forma recursiva, enquanto o valor da posição do início do vetor for menor que o da posição do fim.
				</p><p class="topicos">
				SelectSort: implementado da mesma forma que vimos em aula. Percorre o vetor, substituindo os valores nas respectivas posições corretas.
				</p><p class="topicos">
				GeraVetor: cria um vetor de inteiros contendo 1024 elementos aleatórios, que podem chegar até 20000.
				</p><p class="topicos">
				CopiaVetor: gera cópias do vetor criado por GeraVetor, para ser possível a análise dos algoritmos de ordenação, com base em um mesmo vetor.
				</p><p class="topicos">
				ImprimeVetor: imprime o vetor de inteiros.
				</p><p class="topicos">
				ChecaHeapInt, InicHeapInt, InsereHeapInt, HeapfyInt, SacodeHeapInt, HeapSortInt: implementadas da mesma forma como descrito acima, porém para um vetor de inteiros, em vez de structs.
				</p><p class="topicos">
				Ao final do trabalho, imprimimos os resultados das quantidades de comparações e trocas de cada algoritmo (QuickSort, SelectSort e HeapSort), e concluímos que o melhor algoritmo de ordenação é o QuickSort, porque é o que executa o menor número de comparações e trocas, especialmente com a implementação da mediana como pivô, que contorna o pior caso, como observado anteriormente. 
				</p><p class="topicos">
				No final de ambas as opções (Pronto Socorro e Análise de Algoritmos), executamos a função <em>free()</em>, para liberar toda a memória alocada para os vetores utilizados. Ademais, colocamos, em todo o código, verificações de que as alocações ocorreram como o esperado. No caso de não ser possível alocar um vetor, o programa retorna -1 (erro) e encerra a execução.
				</p>

				<h3>Como usar nosso código:</h3>
				<p>Primeiro, mude para a pasta /codigosC e digite make no terminal para compilar o programa</p>
				<img src="assets/imagens/compilando.png">
				<h4>Se a opção 1 for a escolhida:</h4>
				<p>Aparece um menu para a enfermeira escolher o que ela quer fazer</p>
				<img src="assets/imagens/menu-inicial.png">
				<p>Adicionando um paciente na fila de espera ao apertar 1:</p>
				<img src="assets/imagens/paciente.png">
				<img src="assets/imagens/inserindopaciente.png">
				<p>Após adicionar vários pacientes, removendo um da fila de espera ao apertar 2:</p>
				<img class="tipo2" src="assets/imagens/removendopaciente.png">
				<img class="tipo2" src="assets/imagens/pacienteremovido.png">
				<p>Alterando a prioridade de um paciente ao apertar 3:</p>
				<img class="tipo2" src="assets/imagens/alterando.png">
				<img class="tipo2" src="assets/imagens/prioridade-alterada.png">
				<p>Ordenando a fila de espera para ordem crescente ao apertar 4:</p>
				<img class="tipo2" src="assets/imagens/ordemcrescente.png">
				<p>Fazendo a fila voltar a ser Heap ao apertar 5:</p>
				<img class="tipo2" src="assets/imagens/listaheap.png">
				<p>Mostrando como está a fila de espera ao apertar 6:</p>
				<img class="tipo2" src="assets/imagens/mostralista.png">
				<p>Encerrando o turno (o programa) ao apertar 0:</p>
				<img src="assets/imagens/encerrando.png">
				<h4>Se a opção 2 for a escolhida:</h4>
				<img class="tipo5" src="assets/imagens/opcao2.png" alt="">
				<p>Sempre gera um vetor diferente! Mostrando outro exemplo:</p>
				<img class="tipo5" src="assets/imagens/opcao2outra.png" alt="">

				<h3>26/10/2025</h3>
				<p>Fizemos uma reunião online, na qual implementamos as funções que usaríamos no Heap "Fila de espera". As funções que já tínhamos visto em aula, foram totalmente baseadas nas que o professor passou.
					Já as que nunca tínhamos visto, implementamos como descrevemos acima.
				</p>
				<h4>Observação:</h4> <p>Estávamos usando uma struct paciente diferente apenas para implementar as funções corretamente, a qual era assim:</p>
				<img class="tipo3" src="assets/imagens/struct-antiga.png" >
				<p>Em vez de usarmos um campo nome, estávamos usando um campo idade. Isso, porque ainda não sabíamos muito bem como manipular o tipo char. Então, no período de testes utilizamos o tipo int.</p>
				
				<h3>29/10/2025</h3>
				<p>Começamos a organizar nossas funções. Nesse dia, tivemos a ideia de fazer uma biblioteca de funções, como aprendemos na matéria de Programação I. Além disso, criamos o makefile.</p>
				<p>A biblioteca com apenas as funções que já havíamos implementado:</p>
				<img class="tipo3" src="assets/imagens/functionsH.png">
				<p>O makefile:</p>
				<img class="tipo4" src="assets/imagens/makefile.png">
				<p>A main ainda não estava pronta, mas já a incluímos no makefile para adiantar o processo. 
					Nesse dia, tínhamos somente as funções do Heap "Fila de espera" feitas (ainda com int) no functions.c, uma biblioteca de funções no functions.h e um makefile.
				</p>

				<h3>03/11/2025</h3>
				<p>Fizemos a main, e criamos nosso Menu Inicial. Nele, há como escolher qual caminho seguir: o Pronto Socorro ou a Análise de Algoritmos. Porém, ainda não tínhamos nenhuma função de ordenação pronta. Então, o programa executava a opção 1 (Pronto Socorro), e encerrava, no caso da opção 2 (Análise de Algoritmos).</p>
				<p>Aqui tem uma demonstração do menu e o que acontecia quando se apertava 1, que era só o que funcionava nesse dia:</p>
				<img class="tipo4" src="assets/imagens/menu-inicial.png" alt="">
				<p>Dentro do menu de escolha já estavam funcionando as opções 1, 2, 3, 6 e 0. Para a 4, ainda faltava implementar as funções de ordenação, pois ela precisa do HeapSort. Consequentemente, a 5 (Heapfy) ainda não tinha utilidade, uma vez que está presente nas funções InsereHeap, RemoveHeap e AlteraHeap.</p>

				<h3>04/11/2025</h3>
				<p>Mudamos o campo idade da struct paciente para nome (char). Fizemos todas as alterações nas funções para elas funcionarem com char. As que mais mudaram foram essas:</p>
				<p>Esta é para inserir o nome do paciente no vetor. Como nunca tínhamos criado funções utilizando char, tivemos que pesquisar e estudar sobre:</p>
				<img src="assets/imagens/inserindonome.png" alt="">
				<p>Esta é para comparar dois nomes. Também tivemos que pesquisar porque existe uma função específica para isso que fica na biblioteca string.h, a qual tivemos que importar:</p>
				<img src="assets/imagens/comparandonomes.png" alt="">
				<p>Nesse dia, também implementamos as funções de ordenação e adicionamos suas declarações na nossa biblioteca:</p>
				<img class="tipo4" src="assets/imagens/functionsAtualizado.png" alt="">
				<p> Além disso, implementamos a execução da opção 2, que trata da análise dos algoritmos de ordenação. Para gerar os valores no período de testes, utilizamos a seed 0 que padroniza a criação do vetor para detectarmos possíveis erros.</p>
				<img class="tipo5" src="assets/imagens/ordenacao.png" alt="">

				<h3>05/11/2025</h3>
				<p>Alteramos a seed para, a cada execução, gerar um vetor diferente. Para isso importamos a biblioteca time.h</p>
				<img class="tipo3" src="assets/imagens/seed.png" alt="">
				
				<h3>06/11/2025</h3>
				<p>Fizemos os testes finais, ajustamos algumas funções e seus nomes e alteramos alguns comentários.</p>

			</section>
		</main>

		<footer>
			✿ Feito por: Isabella Stuart (GRR20252459) e Isadora Rodrigues (GRR20252213) ✿
		</footer>
	</body>
</html>